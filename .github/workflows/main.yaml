name: CI Pipeline

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master branch
on:
  push:
    branches:
      - "**"
    tags:
      - "*.*.*"
    paths:
      - "**"
      - "!docs/**"
      - "!examples/**"
      - "!interaction_experiments/**"
      - "!k8s/**"
  pull_request:
    paths:
      - "**"
      - "!docs/**"
      - "!examples/**"
      - "!interaction_experiments/**"
      - "!k8s/**"

env:
  TERM: xterm
  # enable Docker push only if the required secrets are defined
  ENABLE_DOCKER_PUSH: ${{ secrets.DOCKERHUB_USER != null && secrets.DOCKERHUB_TOKEN != null }}
  TEST_TAG: kikkomep/lifemonitor:test
  LATEST_TAG: kikkomep/lifemonitor:test

jobs:
  build:
    name: "Build, Test and Push Docker Image"
    runs-on: ubuntu-latest
    steps:
      - name: "test"
        run: "docker images"      
      -
        name: Checkout
        uses: actions/checkout@v3
      -
        name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      -
        name: Generate certificates
        run: make certs
      # So now you can use Actions' own caching!
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      - 
        name: "Set software version"
        run: |
          git fetch --unshallow
          sw_version=$(python3 -c 'import lifemonitor; print(lifemonitor.__version__)')
          echo "Current Software Version: ${sw_version}"
          echo "SOFTWARE_VERSION=${sw_version}" >> $GITHUB_ENV
          echo "SOFTWARE_VERSION_AS_DOCKER_TAG=$( echo ${sw_version} | tr + _ )" >> $GITHUB_ENV
      # Set Docker image
      - 
        name: Set up Docker repository
        run: echo "DOCKERHUB_REPO=$( if [[ -n $USER_REPO ]]; then echo $USER_REPO; else echo $GITHUB_REPOSITORY; fi )" >> $GITHUB_ENV
        env:
          USER_REPO: ${{ secrets.DOCKERHUB_REPO }}
      # Extract Docker metadata
      - 
        name: Extract Docker metadata
        id: docker_meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ env.SOFTWARE_VERSION_AS_DOCKER_TAG }}
            type=raw,value=${{ env.SOFTWARE_VERSION_AS_DOCKER_TAG}}.build${{ github.run_number }}
            type=sha
          labels: |
            org.opencontainers.image.version=${{ env.SOFTWARE_VERSION }}.build${{ github.run_number }}
      -
        name: Build Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          file: docker/lifemonitor.Dockerfile
          tags: ${{ steps.docker_meta.outputs.tags }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
          load: true
      # -
      #   name: Upload Docker image
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: lifemonitor-image
      #     path: /tmp/lifemonitor-image.tar
      # -
      #   name: Prepare LifeMonitor Repository
      #   run: tar -zcvf /tmp/lifemonitor-repo.tar.gz ./
      # -
      #   name: Upload LifeMonitor Repository
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: lifemonitor-repo
      #     path: /tmp/lifemonitor-repo.tar.gz
      - name: Update cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      -
        name: Run Tests
        run: |
          docker run --rm --entrypoint=/bin/bash kikkomep/lifemonitor:latest -c "ls -larth"
      -
        name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      -
        name: Push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          file: docker/lifemonitor.Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.docker_meta.outputs.tags }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          cache-from: type=local,src=/tmp/.buildx-cache
  
  
  # test:
  #   name: "Test LifeMonitor on Docker Image"
  #   runs-on: ubuntu-latest
  #   needs: build
  #   steps:
  #     -
  #       name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v2
  #     -
  #       name: Download artifact
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: lifemonitor-image
  #         path: /tmp
  #     -
  #       name: Load image
  #       run: |
  #         docker load --input /tmp/lifemonitor-image.tar
  #         docker image ls -a
      
  # push:
  #   name: "Push LifeMonitor Docker Image"
  #   runs-on: ubuntu-latest
  #   needs: test
  #   steps:
  #     -
  #       name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v2
  #     -
  #       name: Download artifact
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: lifemonitor-image
  #         path: /tmp
  #     -
  #       name: Download repo
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: lifemonitor-repo
  #         path: /tmp/lifemonitor-repo.tar 
  #     -
  #       name: Extract LifeMonitor Repository
  #       run: tar -xzvf /tmp/lifemonitor-repo.tar.gz -C ./
  #     -
  #       name: Load image
  #       run: |
  #         docker load --input /tmp/lifemonitor-image.tar
  #     -
  #       name: Login to Docker Hub
  #       uses: docker/login-action@v2
  #       with:
  #         username: ${{ secrets.DOCKERHUB_USER }}
  #         password: ${{ secrets.DOCKERHUB_TOKEN }}
  #     -
  #       name: Build and push
  #       uses: docker/build-push-action@v3
  #       with:
  #         context: .
  #         file: docker/lifemonitor.Dockerfile
  #         platforms: linux/amd64
  #         push: true
  #         tags: ${{ env.LATEST_TAG }}
  #         cache-from: type=local,src=/tmp/.buildx-cache


  # # Verifies pep8, pyflakes and circular complexity
  # flake8:
  #   name: Check Flake8 (python ${{ matrix.python-version }})
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       python-version: [3.7]
  #   steps:
  #     # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
  #     - uses: actions/checkout@v3
  #     - name: Set up Python v${{ matrix.python-version }}
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ matrix.python-version }}
  #     - name: Install flake8
  #       run: pip install flake8
  #     - name: Run checks
  #       run: flake8 -v .

  # # Validate OpenAPI specs
  # openapi_specs:
  #   name: Check OpenAPI Specs (python ${{ matrix.python-version }})
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       python-version: [3.7]
  #   steps:
  #     # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
  #     - uses: actions/checkout@v3
  #     - name: Set up Python v${{ matrix.python-version }}
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ matrix.python-version }}
  #     - name: Install OpenAPI Spec Validator
  #       run: pip install openapi-spec-validator
  #     - name: Run checks
  #       run: openapi-spec-validator specs/api.yaml

  # # Build, Test and Push Docker image
  # tests:
  #   name: Build, Test and Push Docker image
  #   runs-on: ubuntu-latest
  #   needs: [flake8, openapi_specs]
  #   steps:
  #     # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
  #     - uses: actions/checkout@v3
  #     - uses: actions/setup-python@v4
  #       with:
  #         python-version: "3.7"
      # - name: "Set software version"
      #   run: |
      #     git fetch --unshallow
      #     sw_version=$(python3 -c 'import lifemonitor; print(lifemonitor.__version__)')
      #     echo "SOFTWARE_VERSION=${sw_version}" >> $GITHUB_ENV
      #     echo "SOFTWARE_VERSION_AS_DOCKER_TAG=$( echo ${sw_version} | tr + _ )" >> $GITHUB_ENV
      # # Set Docker image
      # - name: Set up Docker repository
      #   run: echo "DOCKERHUB_REPO=$( if [[ -n $USER_REPO ]]; then echo $USER_REPO; else echo $GITHUB_REPOSITORY; fi )" >> $GITHUB_ENV
      #   env:
      #     USER_REPO: ${{ secrets.DOCKERHUB_REPO }}
      # # Extract Docker metadata
      # - name: Extract Docker metadata
      #   id: docker_meta
      #   uses: docker/metadata-action@v3
      #   with:
      #     images: ${{ env.DOCKERHUB_REPO }}
      #     tags: |
      #       type=ref,event=branch
      #       type=ref,event=pr
      #       type=semver,pattern={{version}}
      #       type=semver,pattern={{major}}.{{minor}}
      #       type=raw,value=${{ env.SOFTWARE_VERSION_AS_DOCKER_TAG }}
      #       type=raw,value=${{ env.SOFTWARE_VERSION_AS_DOCKER_TAG}}.build${{ github.run_number }}
      #       type=sha
      #     labels: |
      #       org.opencontainers.image.version=${{ env.SOFTWARE_VERSION }}.build${{ github.run_number }}
  #     # Set up Docker tags
  #     - name: Set up Docker tags
  #       run: |
  #         IFS=$'\n'      # Change IFS to new line
  #         tags=($TAGS)   # split to array
  #         echo "DOCKER_TAGS=$(printf "'%s' " "${tags[@]}")" >> $GITHUB_ENV
  #       env:
  #         TAGS: ${{ steps.docker_meta.outputs.tags }}
  #     # Set up Docker labels
  #     - name: Set up Docker labels
  #       run: |
  #         sw_version=$(python3 -c 'import lifemonitor; print(lifemonitor.__version__)')
  #         IFS=$'\n'      # Change IFS to new line
  #         labels=($LABELS) # split to array $names
  #         echo "DOCKER_LABELS=$(printf "'%s' " "${labels[@]}")" >> $GITHUB_ENV
  #       env:
  #         LABELS: ${{ steps.docker_meta.outputs.labels }}
  #     # Build Docker image
  #     - name: Build Docker image
  #       run: |
  #         TAGS=${DOCKER_TAGS} LABELS=${DOCKER_LABELS} \
  #         SW_VERSION=${SOFTWARE_VERSION}.build${{ github.run_number }} \
  #         BUILD_NUMBER=${{ github.run_number }} \
  #         make lifemonitor
  #     # Setup testing environment
  #     - name: Set up testing environment
  #       run: TAGS=${DOCKER_TAGS} LABELS=${DOCKER_LABELS} make start-testing
  #       env:
  #         TRAVIS_TESTING_SERVICE_URL: ${{ secrets.TRAVIS_TESTING_SERVICE_URL }}
  #         TRAVIS_TESTING_SERVICE_TOKEN: ${{ secrets.TRAVIS_TESTING_SERVICE_TOKEN }}
  #         TRAVIS_TESTING_SERVICE_TYPE: travis
  #         GH_TESTING_SERVICE_URL: ${{ secrets.GH_TESTING_SERVICE_URL }}
  #         GH_TESTING_SERVICE_TOKEN: ${{ secrets.GH_TESTING_SERVICE_TOKEN }}
  #         GH_TESTING_SERVICE_TYPE: github
  #     # Run tests
  #     - name: Run tests
  #       run: TAGS=${DOCKER_TAGS} LABELS=${DOCKER_LABELS} make run-tests
  #       env:
  #         TRAVIS_TESTING_SERVICE_URL: ${{ secrets.TRAVIS_TESTING_SERVICE_URL }}
  #         TRAVIS_TESTING_SERVICE_TOKEN: ${{ secrets.TRAVIS_TESTING_SERVICE_TOKEN }}
  #         TRAVIS_TESTING_SERVICE_TYPE: travis
  #         GH_TESTING_SERVICE_URL: ${{ secrets.GH_TESTING_SERVICE_URL }}
  #         GH_TESTING_SERVICE_TOKEN: ${{ secrets.GH_TESTING_SERVICE_TOKEN }}
  #         GH_TESTING_SERVICE_TYPE: github
  #     # Teardown testing environment
  #     - name: Teardown testing environment
  #       run: make down
  #     # DockerHub Login
  #     - name: Login to DockerHub
  #       uses: docker/login-action@v2
  #       if: ${{ env.ENABLE_DOCKER_PUSH == 'true' }}
  #       with:
  #         username: ${{ secrets.DOCKERHUB_USER }}
  #         password: ${{ secrets.DOCKERHUB_TOKEN }}
  #     # Push Docker image
  #     - name: Push Docker image
  #       if: ${{ env.ENABLE_DOCKER_PUSH == 'true' }}
  #       run: |
  #         IFS=$'\n'      # Change IFS to new line
  #         tags=($TAGS)   # split to array
  #         for t in "${tags[@]}"; do
  #             echo "Pushing tag: $t"
  #             docker push ${t}
  #         done
  #       env:
  #         TAGS: ${{ steps.docker_meta.outputs.tags }}
  #     # Clean up
  #     - name: Clean up working environment
  #       run: make clean
